true_beta[1:10,1]<-c(3,-3,-3,3,3,3,-3,-3,3,3)
true_beta[(p+5):(p+9),]<-c(1.5,-1.5,1.5,-1.5,1.5)
true_beta["E",1]<-betaE
}
not_causal <- setdiff(vnames, causal)
xtrain <- gendata$x[1:split_value,]
ytrain = gendata$y[1:split_value]
etrain = gendata$e[1:split_value]
xtest = gendata$x[(split_value+1):n,]
ytest = gendata$y[(split_value+1):n]
etest = gendata$e[(split_value+1):n]
xvalid = gendata_valid$x
yvalid = gendata_valid$y
evalid = gendata_valid$e
# as is done in pliable lasso, only feed (E,X) to glmnet
x_main <- cbind(E = etrain, xtrain)
# test set
x_main_test <- cbind(E = etest, xtest)
# validation set
x_main_valid <- cbind(E = evalid, xvalid)
result<-list("x_train" = xtrain , "y_train" = ytrain, "e_train" = etrain, "xtrain_lasso" = x_main,
"x_test" = xtest, "y_test" = ytest,"e_test" = etest, "xtest_lasso" = x_main_test,
"x_valid" = xvalid, "y_valid" = yvalid, "e_valid" = evalid, "xvalid_lasso" = x_main_valid,
"vnames" = vnames, "vnames_lasso"=vnames_lasso,"betaE"= betaE,"true_beta" = true_beta,
"causal" = causal , "not_causal" = not_causal
)
return (result)
}
betaE <- 2
# Third parameter indicate the case1
data<-generate_data_case2(100,30,betaE,1)
####
#          glinternet ---------------------------------------
####
# install.packages("glinternet")
library(glinternet)
fitGL <- glinternet(X = data$xtrain_lasso, Y = data$y_train,
numLevels = rep(1, ncol(data$xtrain_lasso)),
nLambda = 100,interactionCandidates = c(1),
verbose = F)
ytest_hat <- predict(fitGL, X = data$xtest_lasso)
msetest <- colMeans((data$y_test - ytest_hat)^2)
lambda.min.index <- as.numeric(which.min(msetest))
lambda.min <- fitGL$lambda[which.min(msetest)]
yvalid_hat <- predict(fitGL, X = data$xvalid_lasso, lambda = lambda.min)
msevalid <- mean((data$y_valid - drop(yvalid_hat))^2)
yvalid_hat
y_function<-function(n, p, corr=0, betaE = 2, SNR = 2, case){
# covariates
W <- replicate(n = p, truncnorm::rtruncnorm(n, a = 0, b = 1))
U <- truncnorm::rtruncnorm(n, a = 0, b = 1)
V <- truncnorm::rtruncnorm(n, a = 0, b = 1)
E <- stats::rnorm(n)
Y<-0
X1 <- (W[, 1] + corr * U) / (1 + corr)
X2 <- (W[, 2] + corr * U) / (1 + corr)
X3 <- (W[, 3] + corr * U) / (1 + corr)
X4 <- (W[, 4] + corr * U) / (1 + corr)
X5 <- (W[, 5] + corr * U) / (1 + corr)
if (case==1){
X <- (W[, 6:p] + corr * V) / (1 + corr)
Xall <- cbind(X1, X2, X3, X4, X5, X)
colnames(Xall) <- paste0("X", seq_len(p))
f1 <- function(x) 3 * x
f2 <- function(x) -3 * x
f3 <- function(x) -3 * x
f4 <- function(x) 3 * x
f5 <- function(x) 3 * x
f4.inter = function(x, e) 1.5 * e * x
f5.inter = function(x, e) -1.5 * e * x
# 5 main effects + 2 interaction
Y <- f1(X1) + f2(X2) + f3(X3) + f4(X4) + f5(X5) + betaE*E + f4.inter(X4,E) + f5.inter(X5,E) + rnorm(n)
}
else{
X6 <- (W[, 6] + corr * U) / (1 + corr)
X7 <- (W[, 7] + corr * U) / (1 + corr)
X8 <- (W[, 8] + corr * U) / (1 + corr)
X9 <- (W[, 9] + corr * U) / (1 + corr)
X10 <- (W[, 10] + corr * U) / (1 + corr)
X <- (W[, 11:p] + corr * V) / (1 + corr)
Xall <- cbind(X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X)
colnames(Xall) <- paste0("X", seq_len(p))
f1 <- function(x) 3 * x
f2 <- function(x) -3 * x
f3 <- function(x) -3 * x
f4 <- function(x) 3 * x
f5 <- function(x) 3 * x
f6 <- function(x) 3 * x
f7 <- function(x) -3 * x
f8 <- function(x) -3 * x
f9 <- function(x) 3 * x
f10 <- function(x) 3 * x
f4.inter = function(x, e) 1.5 * e * x
f5.inter = function(x, e) -1.5 * e * x
f6.inter = function(x, e) 1.5 * e * x
f7.inter = function(x, e) -1.5 * e * x
f8.inter = function(x, e) 1.5 * e * x
Y <- f1(X1) + f2(X2) + f3(X3) + f4(X4) + f5(X5) +
f6(X6) + f7(X7) + f8(X8) + f9(X9) + f10(X10)+
betaE*E + f4.inter(X4,E) + f5.inter(X5,E) +
f6.inter(X6,E) + f7.inter(X7,E) +
f8.inter(X8,E) + rnorm(n)
}
return(list(x = Xall, y = Y ,e = E))
}
generate_data_case2<-function(n,p,betaE,case){
# test and training set
# X <- matrix(rnorm(n*p), nrow=n)
# X <- scale(X,TRUE,TRUE)
gendata <- y_function(n,p,0,0,betaE,case)
# Y <- y_function(n,p,0,0,2,case)
split_value <- n*0.8
m <- 2*n
gendata_valid <- y_function(m,p,0,0,betaE,case)
# X_valid <- matrix(rnorm(m*p), nrow=m)
# Y_valid <-y_function(n,p,0,0,2,case)
main <- paste0("X", seq_len(p))
vnames<-c(main)
vnames<-append(vnames, "E")
for (i in (1:(length(main)))){
conc<-paste(main[i], "E", sep = ":")
vnames<-append(vnames, conc)
}
true_beta<-matrix(0,nrow=(length(vnames)),ncol=1)
true_beta_list<-vnames
rownames(true_beta) <- true_beta_list
colnames(true_beta) <- "true value"
if (case ==1){
causal <- c("X1","X2","X3","X4","X5","E","X4:E","X5:E")
true_beta[1:5,1]<-c(3,-3,-3,3,3)
true_beta[(p+5):(p+6),1]<-c(1.5,-1.5)
true_beta["E",1]<-betaE
}else{
causal <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","E","X4:E","X5:E","X6:E","X7:E","X8:E")
true_beta[1:10,1]<-c(3,-3,-3,3,3,3,-3,-3,3,3)
true_beta[(p+5):(p+9),]<-c(1.5,-1.5,1.5,-1.5,1.5)
true_beta["E",1]<-betaE
}
not_causal <- setdiff(vnames, causal)
result<-list("x_train" = gendata$x[1:split_value,] , "y_train" = gendata$y[1:split_value], "e_train" = gendata$e[1:split_value] ,
"x_test" = gendata$x[(split_value+1):n,], "y_test" = gendata$y[(split_value+1):n],"e_test" = gendata$e[(split_value+1):n],
"x_valid" = gendata_valid$x, "y_valid" = gendata_valid$y, "e_valid" = gendata_valid$e,
"vnames" = vnames, "betaE"= betaE,"true_beta" = true_beta,
"causal" = causal , "not_causal" = not_causal
)
return (result)
}
betaE <- 2
# Third parameter indicate the case1
data<-generate_data_case2(100,30,betaE,1)
data$true_beta
fit_model <- gesso.fit(G = data$x_train, E = data$e_train, Y = data$y_train,
normalize=TRUE,family = "gaussian", min_working_set_size = 30)
msetest<-1000000
lambda1_index<- -1
lambda2_index<- -1
y_function<-function(n, p, corr=0, betaE = 2, SNR = 2, case){
# covariates
W <- replicate(n = p, truncnorm::rtruncnorm(n, a = 0, b = 1))
U <- truncnorm::rtruncnorm(n, a = 0, b = 1)
V <- truncnorm::rtruncnorm(n, a = 0, b = 1)
E <- stats::rnorm(n)
Y<-0
X1 <- (W[, 1] + corr * U) / (1 + corr)
X2 <- (W[, 2] + corr * U) / (1 + corr)
X3 <- (W[, 3] + corr * U) / (1 + corr)
X4 <- (W[, 4] + corr * U) / (1 + corr)
X5 <- (W[, 5] + corr * U) / (1 + corr)
if (case==1){
X <- (W[, 6:p] + corr * V) / (1 + corr)
Xall <- cbind(X1, X2, X3, X4, X5, X)
colnames(Xall) <- paste0("X", seq_len(p))
f1 <- function(x) 3 * x
f2 <- function(x) -3 * x
f3 <- function(x) -3 * x
f4 <- function(x) 3 * x
f5 <- function(x) 3 * x
f4.inter = function(x, e) 1.5 * e * x
f5.inter = function(x, e) -1.5 * e * x
# 5 main effects + 2 interaction
Y <- f1(X1) + f2(X2) + f3(X3) + f4(X4) + f5(X5) + betaE*E + f4.inter(X4,E) + f5.inter(X5,E) + rnorm(n)
}
else{
X6 <- (W[, 6] + corr * U) / (1 + corr)
X7 <- (W[, 7] + corr * U) / (1 + corr)
X8 <- (W[, 8] + corr * U) / (1 + corr)
X9 <- (W[, 9] + corr * U) / (1 + corr)
X10 <- (W[, 10] + corr * U) / (1 + corr)
X <- (W[, 11:p] + corr * V) / (1 + corr)
Xall <- cbind(X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X)
colnames(Xall) <- paste0("X", seq_len(p))
f1 <- function(x) 3 * x
f2 <- function(x) -3 * x
f3 <- function(x) -3 * x
f4 <- function(x) 3 * x
f5 <- function(x) 3 * x
f6 <- function(x) 3 * x
f7 <- function(x) -3 * x
f8 <- function(x) -3 * x
f9 <- function(x) 3 * x
f10 <- function(x) 3 * x
f4.inter = function(x, e) 1.5 * e * x
f5.inter = function(x, e) -1.5 * e * x
f6.inter = function(x, e) 1.5 * e * x
f7.inter = function(x, e) -1.5 * e * x
f8.inter = function(x, e) 1.5 * e * x
Y <- f1(X1) + f2(X2) + f3(X3) + f4(X4) + f5(X5) +
f6(X6) + f7(X7) + f8(X8) + f9(X9) + f10(X10)+
betaE*E + f4.inter(X4,E) + f5.inter(X5,E) +
f6.inter(X6,E) + f7.inter(X7,E) +
f8.inter(X8,E) + rnorm(n)
}
return(list(x = Xall, y = Y ,e = E))
}
generate_data_case2<-function(n,p,betaE,case){
# test and training set
# X <- matrix(rnorm(n*p), nrow=n)
# X <- scale(X,TRUE,TRUE)
gendata <- y_function(n,p,0,0,betaE,case)
# Y <- y_function(n,p,0,0,2,case)
split_value <- n*0.8
m <- 2*n
gendata_valid <- y_function(m,p,0,0,betaE,case)
# X_valid <- matrix(rnorm(m*p), nrow=m)
# Y_valid <-y_function(n,p,0,0,2,case)
main <- paste0("X", seq_len(p))
vnames<-c(main)
for (i in (1:(length(main)))){
conc<-paste(main[i], "E", sep = ":")
vnames<-append(vnames, conc)
}
if (case ==1){
causal <- c("X1","X2","X3","X4","X5","X4:E","X5:E")
}else if (case ==2){
causal <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","X4:E","X5:E","X6:E","X7:E","X8:E")
}else if (case ==3){
causal <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","X4:E","X5:E","X6:E","X7:E","X8:E")
}
not_causal <- setdiff(vnames, causal)
result<-list("x_train" = gendata$x[1:split_value,] , "y_train" = gendata$y[1:split_value], "e_train" = gendata$e[1:split_value] ,
"x_test" = gendata$x[(split_value+1):n,], "y_test" = gendata$y[(split_value+1):n],"e_test" = gendata$e[(split_value+1):n],
"x_valid" = gendata_valid$x, "y_valid" = gendata_valid$y, "e_valid" = gendata_valid$e,
"vnames" = vnames, "betaE"= betaE,
"causal" = causal , "not_causal" = not_causal
)
return (result)
}
betaE <- 2
# Third parameter indicate the case1
data<-generate_data_case2(100,30,betaE,1)
fit <- sail(x = data$x_train, y = data$y_train, e = data$e_train,
basis = function(i) i)
ytest_hat <- predict(fit, newx = data$x_test, newe = data$e_test)
ytest_hat
msetest <- colMeans((data$y_test - ytest_hat)^2)
lambda.min.index <- as.numeric(which.min(msetest))
lambda.min <- fit$lambda[which.min(msetest)]
yvalid_hat <- predict(fit, newx = data$x_valid, newe = data$e_valid, s = lambda.min)
yvalid_hat
y_function<-function(n, p, corr=0, betaE = 2, SNR = 2, case){
# covariates
W <- replicate(n = p, truncnorm::rtruncnorm(n, a = 0, b = 1))
U <- truncnorm::rtruncnorm(n, a = 0, b = 1)
V <- truncnorm::rtruncnorm(n, a = 0, b = 1)
E <- stats::rnorm(n)
Y<-0
X1 <- (W[, 1] + corr * U) / (1 + corr)
X2 <- (W[, 2] + corr * U) / (1 + corr)
X3 <- (W[, 3] + corr * U) / (1 + corr)
X4 <- (W[, 4] + corr * U) / (1 + corr)
X5 <- (W[, 5] + corr * U) / (1 + corr)
if (case==1){
X <- (W[, 6:p] + corr * V) / (1 + corr)
Xall <- cbind(X1, X2, X3, X4, X5, X)
colnames(Xall) <- paste0("X", seq_len(p))
f1 <- function(x) 3 * x
f2 <- function(x) -3 * x
f3 <- function(x) -3 * x
f4 <- function(x) 3 * x
f5 <- function(x) 3 * x
f4.inter = function(x, e) 1.5 * e * x
f5.inter = function(x, e) -1.5 * e * x
# 5 main effects + 2 interaction
Y <- f1(X1) + f2(X2) + f3(X3) + f4(X4) + f5(X5) + betaE*E + f4.inter(X4,E) + f5.inter(X5,E) + rnorm(n)
}
else{
X6 <- (W[, 6] + corr * U) / (1 + corr)
X7 <- (W[, 7] + corr * U) / (1 + corr)
X8 <- (W[, 8] + corr * U) / (1 + corr)
X9 <- (W[, 9] + corr * U) / (1 + corr)
X10 <- (W[, 10] + corr * U) / (1 + corr)
X <- (W[, 11:p] + corr * V) / (1 + corr)
Xall <- cbind(X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X)
colnames(Xall) <- paste0("X", seq_len(p))
f1 <- function(x) 3 * x
f2 <- function(x) -3 * x
f3 <- function(x) -3 * x
f4 <- function(x) 3 * x
f5 <- function(x) 3 * x
f6 <- function(x) 3 * x
f7 <- function(x) -3 * x
f8 <- function(x) -3 * x
f9 <- function(x) 3 * x
f10 <- function(x) 3 * x
f4.inter = function(x, e) 1.5 * e * x
f5.inter = function(x, e) -1.5 * e * x
f6.inter = function(x, e) 1.5 * e * x
f7.inter = function(x, e) -1.5 * e * x
f8.inter = function(x, e) 1.5 * e * x
Y <- f1(X1) + f2(X2) + f3(X3) + f4(X4) + f5(X5) +
f6(X6) + f7(X7) + f8(X8) + f9(X9) + f10(X10)+
betaE*E + f4.inter(X4,E) + f5.inter(X5,E) +
f6.inter(X6,E) + f7.inter(X7,E) +
f8.inter(X8,E) + rnorm(n)
}
return(list(x = Xall, y = Y ,e = E))
}
generate_data_case2<-function(n,p,betaE,case){
# test and training set
# X <- matrix(rnorm(n*p), nrow=n)
# X <- scale(X,TRUE,TRUE)
gendata <- y_function(n,p,0,0,betaE,case)
# Y <- y_function(n,p,0,0,2,case)
split_value <- n*0.8
m <- 2*n
gendata_valid <- y_function(m,p,0,0,betaE,case)
# X_valid <- matrix(rnorm(m*p), nrow=m)
# Y_valid <-y_function(n,p,0,0,2,case)
main <- paste0("X", seq_len(p))
vnames_lasso <- c("E", main) # needs to be in this order for glinternet
vnames<-c(main)
vnames<-append(vnames, "E") # others
for (i in (1:(length(main)))){
conc<-paste(main[i], "E", sep = ":")
vnames<-append(vnames, conc)
vnames_lasso<-append(vnames_lasso, conc)
}
true_beta<-matrix(0,nrow=(length(vnames)),ncol=1)
true_beta_list<-vnames
rownames(true_beta) <- true_beta_list
colnames(true_beta) <- "true value"
if (case ==1){
causal <- c("X1","X2","X3","X4","X5","E","X4:E","X5:E")
true_beta[1:5,1]<-c(3,-3,-3,3,3)
true_beta[(p+5):(p+6),1]<-c(1.5,-1.5)
true_beta["E",1]<-betaE
}else{
causal <- c("X1","X2","X3","X4","X5","X6","X7","X8","X9","X10","E","X4:E","X5:E","X6:E","X7:E","X8:E")
true_beta[1:10,1]<-c(3,-3,-3,3,3,3,-3,-3,3,3)
true_beta[(p+5):(p+9),]<-c(1.5,-1.5,1.5,-1.5,1.5)
true_beta["E",1]<-betaE
}
not_causal <- setdiff(vnames, causal)
xtrain <- gendata$x[1:split_value,]
ytrain = gendata$y[1:split_value]
etrain = gendata$e[1:split_value]
xtest = gendata$x[(split_value+1):n,]
ytest = gendata$y[(split_value+1):n]
etest = gendata$e[(split_value+1):n]
xvalid = gendata_valid$x
yvalid = gendata_valid$y
evalid = gendata_valid$e
# as is done in pliable lasso, only feed (E,X) to glmnet
x_main <- cbind(E = etrain, xtrain)
# test set
x_main_test <- cbind(E = etest, xtest)
# validation set
x_main_valid <- cbind(E = evalid, xvalid)
result<-list("x_train" = xtrain , "y_train" = ytrain, "e_train" = etrain, "xtrain_lasso" = x_main,
"x_test" = xtest, "y_test" = ytest,"e_test" = etest, "xtest_lasso" = x_main_test,
"x_valid" = xvalid, "y_valid" = yvalid, "e_valid" = evalid, "xvalid_lasso" = x_main_valid,
"vnames" = vnames, "vnames_lasso"=vnames_lasso,"betaE"= betaE,"true_beta" = true_beta,
"causal" = causal , "not_causal" = not_causal
)
return (result)
}
betaE <- 2
# Third parameter indicate the case1
data<-generate_data_case2(100,30,betaE,1)
####
#          glinternet ---------------------------------------
####
# install.packages("glinternet")
library(glinternet)
fitGL <- glinternet(X = data$xtrain_lasso, Y = data$y_train,
numLevels = rep(1, ncol(data$xtrain_lasso)),
nLambda = 100,interactionCandidates = c(1),
verbose = F)
ytest_hat <- predict(fitGL, X = data$xtest_lasso)
msetest <- colMeans((data$y_test - ytest_hat)^2)
lambda.min.index <- as.numeric(which.min(msetest))
lambda.min <- fitGL$lambda[which.min(msetest)]
yvalid_hat <- predict(fitGL, X = data$xvalid_lasso, lambda = lambda.min)
yvalid_hat
pacman::p_load(simulator)
pacman::p_load(gesso)
pacman::p_load(sail)
pacman::p_load(glinternet)
pacman::p_load(magrittr)
pacman::p_load(dplyr)
pacman::p_load(tidyr)
pacman::p_load(ggplot2)
source("/Users/rongyu/Desktop/Simulation/sims/eval_functions.R")
source("/Users/rongyu/Desktop/Simulation/sims/method_functions.R")
source("/Users/rongyu/Desktop/Simulation/sims/model_functions.R")
name_of_simulation <- "normal-mean-estimation-with-contamination"
## @knitr main
sim <- new_simulation(name = "2022",
label = "2022_try",
dir = ".") %>%
generate_model(make_XE_data_split,seed = 1234,
n = 100, p=30, corr= 0, betaE = 2, SNR = 2,
lambda.type = "lambda.min",parameterIndex = list(1),vary_along = "parameterIndex") %>%
simulate_from_model(nsim = 1, index = 1:2) %>%
run_method(list(gessosplit,sailsplit,glinternetsplit_XE),
parallel = list(socket_names = 35,
libraries = c("splines",
"magrittr","gesso","sail","glinternet","simulator","parallel")))
simulator::save_simulation(sim)
sim <- sim %>% evaluate(list(msevalid, tpr, fpr, nactive, r2))
sim %>% plot_eval(metric_name = "mse")
as.data.frame(evals(sim))
pacman::p_load(simulator)
pacman::p_load(simulator)
pacman::p_load(gesso)
pacman::p_load(sail)
pacman::p_load(glinternet)
pacman::p_load(magrittr)
pacman::p_load(dplyr)
pacman::p_load(tidyr)
pacman::p_load(ggplot2)
source("/Users/rongyu/Desktop/Simulation/sims/eval_functions.R")
source("/Users/rongyu/Desktop/Simulation/sims/method_functions.R")
source("/Users/rongyu/Desktop/Simulation/sims/model_functions.R")
name_of_simulation <- "normal-mean-estimation-with-contamination"
## @knitr main
sim <- new_simulation(name = "2022",
label = "2022_try",
dir = ".") %>%
generate_model(make_XE_data_split,seed = 1234,
n = 100, p=30, corr= 0, betaE = 2, SNR = 2,
lambda.type = "lambda.min",parameterIndex = list(1),vary_along = "parameterIndex") %>%
simulate_from_model(nsim = 1, index = 1:2) %>%
run_method(list(gessosplit,sailsplit,glinternetsplit_XE),
parallel = list(socket_names = 35,
libraries = c("splines",
"magrittr","gesso","sail","glinternet","simulator","parallel")))
simulator::save_simulation(sim)
sim <- sim %>% evaluate(list(msevalid, tpr, fpr, nactive, r2))
sim %>% plot_eval(metric_name = "mse")
as.data.frame(evals(sim))
pacman::p_load(simulator)
pacman::p_load(gesso)
pacman::p_load(sail)
pacman::p_load(glinternet)
pacman::p_load(magrittr)
pacman::p_load(dplyr)
pacman::p_load(tidyr)
pacman::p_load(ggplot2)
source("/Users/rongyu/Desktop/Simulation/sims/eval_functions.R")
source("/Users/rongyu/Desktop/Simulation/sims/method_functions.R")
source("/Users/rongyu/Desktop/Simulation/sims/model_functions.R")
name_of_simulation <- "normal-mean-estimation-with-contamination"
## @knitr main
# # Simulation Case 7 : GXE, Continuous Outcome, n=100, p=30------------------------
sim7 <- new_simulation(name = "2022_sim7",
label = "2022_sim7_XE_CASE1",
dir = ".") %>%
generate_model(make_XE_data_split,seed = 1234,
n = 100, p=30, corr= 0, betaE = 2, SNR = 2, case = 1,
lambda.type = "lambda.min", vary_along = "parameterIndex") %>%
simulate_from_model(nsim = 1, index = 1:2) %>%
run_method(list(gessosplit,sailsplit,glinternetsplit_XE),
parallel = list(socket_names = 35,
libraries = c("splines",
"magrittr","gesso","sail","glinternet","simulator","parallel")))
source("/Users/rongyu/Desktop/Simulation/sims/eval_functions.R")
source("/Users/rongyu/Desktop/Simulation/sims/method_functions.R")
source("/Users/rongyu/Desktop/Simulation/sims/model_functions.R")
name_of_simulation <- "normal-mean-estimation-with-contamination"
## @knitr main
# # Simulation Case 7 : GXE, Continuous Outcome, n=100, p=30------------------------
sim7 <- new_simulation(name = "2022_sim7",
label = "2022_sim7_XE_CASE1",
dir = ".") %>%
generate_model(make_XE_data_split,seed = 1234,
n = 100, p=30, corr= 0, betaE = 2, SNR = 2, case = 1,
lambda.type = "lambda.min", parameterIndex=list(1), vary_along = "parameterIndex") %>%
simulate_from_model(nsim = 1, index = 1:2) %>%
run_method(list(gessosplit,sailsplit,glinternetsplit_XE),
parallel = list(socket_names = 35,
libraries = c("splines",
"magrittr","gesso","sail","glinternet","simulator","parallel")))
simulator::save_simulation(sim7)
sim7 <- sim7 %>% evaluate(list(msevalid, tpr, fpr, nactive, r2))
sim7 %>% plot_eval(metric_name = "mse")
as.data.frame(evals(sim7))
sim8 <- new_simulation(name = "2022_sim8",
label = "2022_sim8_XE_CASE2",
dir = ".") %>%
generate_model(make_XE_data_split,seed = 1234,
n = 150, p=300, corr= 0, betaE = 2, SNR = 2, case = 2,
lambda.type = "lambda.min", parameterIndex=list(1), vary_along = "parameterIndex") %>%
simulate_from_model(nsim = 1, index = 1:2) %>%
run_method(list(gessosplit,sailsplit,glinternetsplit_XE),
parallel = list(socket_names = 35,
libraries = c("splines",
"magrittr","gesso","sail","glinternet","simulator","parallel")))
simulator::save_simulation(sim8)
sim8 <- sim8 %>% evaluate(list(msevalid, tpr, fpr, nactive, r2))
sim8 %>% plot_eval(metric_name = "mse")
as.data.frame(evals(sim8))
